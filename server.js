// server.js
const express = require('express');
const bodyParser = require('body-parser');
const path = require('path');
const multer = require('multer');
const mongoose = require('mongoose');
const fs = require('fs');
require('dotenv').config(); // T·∫£i bi·∫øn m√¥i tr∆∞·ªùng (v√≠ d·ª•: MONGO_URI)

const app = express();
const PORT = process.env.PORT || 3000;
const UPLOADS_DIR = path.join(__dirname, 'uploads');

// --------------------------------------------------------------------------------
// K·∫æT N·ªêI V√Ä MODEL MONGOOSE
// --------------------------------------------------------------------------------

// K·∫øt n·ªëi t·ªõi MongoDB
mongoose.connect(process.env.MONGO_URI || 'mongodb://localhost:27017/love_site', {
    useNewUrlParser: true,
    useUnifiedTopology: true
}).then(() => {
    console.log("Connected to MongoDB successfully! üíñ");
}).catch(err => {
    console.error("MongoDB connection error:", err);
    process.exit(1);
});

// ƒê·ªãnh nghƒ©a Mongoose Schemas (Collections)
const ConfigSchema = new mongoose.Schema({
    key: { type: String, required: true, unique: true },
    value: { type: String, required: true }
});
const Config = mongoose.model('Config', ConfigSchema);

const MessageSchema = new mongoose.Schema({
    date: { type: Date, required: true },
    message: { type: String, required: true, maxlength: 500 }
});
const Message = mongoose.model('Message', MessageSchema);

const ScoreSchema = new mongoose.Schema({
    playerName: { type: String, default: 'Ng∆∞·ªùi ch∆°i b√≠ m·∫≠t' },
    score: { type: Number, required: true },
    level: { type: Number, default: 1 },
    clicksPerMinute: { type: Number, default: 0 },
    date: { type: Date, default: Date.now }
});
const GameScore = mongoose.model('GameScore', ScoreSchema);

// --------------------------------------------------------------------------------
// LOGIC KH·ªûI T·∫†O DATABASE
// --------------------------------------------------------------------------------

/**
 * Kh·ªüi t·∫°o m·∫≠t kh·∫©u v√† ·∫£nh m·∫∑c ƒë·ªãnh n·∫øu ch√∫ng ch∆∞a t·ªìn t·∫°i.
 */
async function initializeDatabase() {
    try {
        const defaultConfigs = [
            { key: 'site_password', value: 'tinhyeu123' },
            { key: 'admin_password', value: 'admin456' },
            { key: 'love_image', value: 'https://picsum.photos/seed/defaultlove/400/400' }
        ];

        for (const config of defaultConfigs) {
            await Config.findOneAndUpdate({ key: config.key }, { value: config.value }, { upsert: true, new: true, setDefaultsOnInsert: true });
        }
        
        const currentSitePass = await Config.findOne({ key: 'site_password' });
        const currentAdminPass = await Config.findOne({ key: 'admin_password' });

        console.log(`Initial Site password: ${currentSitePass.value}`);
        console.log(`Initial Admin password: ${currentAdminPass.value}`);

    } catch (error) {
        console.error("Error initializing database:", error);
    }
}


// --------------------------------------------------------------------------------
// C·∫§U H√åNH SERVER V√Ä MIDDLEWARE
// --------------------------------------------------------------------------------

// C·∫•u h√¨nh Multer ƒë·ªÉ l∆∞u file t·∫°m th·ªùi
const upload = multer({ dest: UPLOADS_DIR });
if (!fs.existsSync(UPLOADS_DIR)) {
    fs.mkdirSync(UPLOADS_DIR);
}

// Middleware
app.use(bodyParser.json());
app.use(express.static(path.join(__dirname))); 
app.use('/uploads', express.static(UPLOADS_DIR)); 

/**
 * L·∫•y m·∫≠t kh·∫©u t·ª´ DB
 */
async function getPasswords() {
    const configs = await Config.find({ key: { $in: ['site_password', 'admin_password'] } });
    const passwords = {};
    configs.forEach(conf => {
        passwords[conf.key] = conf.value;
    });
    return passwords;
}

/**
 * X√°c th·ª±c cho Trang Ch√≠nh (Site)
 */
const requireSiteAuth = async (req, res, next) => {
    const authHeader = req.headers['authorization'];
    if (!authHeader) return res.status(401).json({ error: 'Authorization header required.' });
    
    const passwords = await getPasswords();
    if (authHeader !== passwords.site_password) {
        return res.status(403).json({ error: 'Invalid site password.' });
    }
    next();
};

/**
 * X√°c th·ª±c cho Admin
 */
const requireAdminAuth = async (req, res, next) => {
    const authHeader = req.headers['authorization'];
    if (!authHeader) return res.status(401).json({ error: 'Authorization header required.' });
    
    const passwords = await getPasswords();
    if (authHeader !== passwords.admin_password) {
        return res.status(403).json({ error: 'Invalid admin password.' });
    }
    next();
};


// --------------------------------------------------------------------------------
// ENDPOINTS PH·ª§C V·ª§ FILE
// --------------------------------------------------------------------------------

app.get('/', (req, res) => res.sendFile(path.join(__dirname, 'index.html')));
app.get('/admin', (req, res) => res.sendFile(path.join(__dirname, 'admin.html')));
app.get('/game', (req, res) => res.sendFile(path.join(__dirname, 'game.html')));
['/tym1', '/tym2', '/tym3', '/tym4'].forEach(route => {
    app.get(route, (req, res) => {
        const fileMap = {
            '/tym1': 'index_tym1.html',
            '/tym2': 'index_tym2.html',
            '/tym3': 'index_tym3.html',
            '/tym4': 'index_tym4.html',
        };
        res.sendFile(path.join(__dirname, fileMap[route]));
    });
});


// --------------------------------------------------------------------------------
// API CHO TRANG CH√çNH (SITE API)
// --------------------------------------------------------------------------------

// GET /api/messages - T·∫£i tin nh·∫Øn + D√πng ƒë·ªÉ x√°c th·ª±c Trang Ch√≠nh
app.get('/api/messages', requireSiteAuth, async (req, res) => {
    try {
        const messages = await Message.find().sort({ date: -1 }); // L·∫•y m·ªõi nh·∫•t tr∆∞·ªõc
        const formattedMessages = messages.map(m => `${m.date.toISOString().split('T')[0]}: ${m.message}`);
        res.json({ messages: formattedMessages });
    } catch (error) {
        console.error("Error fetching messages:", error);
        res.status(500).json({ error: 'Failed to fetch messages.' });
    }
});

// POST /api/messages-with-date - G·ª≠i tin nh·∫Øn t·ª´ Trang Ch√≠nh
app.post('/api/messages-with-date', requireSiteAuth, async (req, res) => {
    const { date, message } = req.body;
    if (!date || !message) {
        return res.status(400).json({ error: 'Date and message are required.' });
    }
    
    try {
        const newMessage = new Message({ date: new Date(date), message });
        await newMessage.save();
        res.json({ message: 'Message posted successfully.' });
    } catch (error) {
        console.error("Error inserting message:", error);
        res.status(500).json({ error: 'Failed to post message.' });
    }
});


// --------------------------------------------------------------------------------
// API CHO TRANG ADMIN (ADMIN API)
// --------------------------------------------------------------------------------

// GET /api/passwords - L·∫•y m·∫≠t kh·∫©u hi·ªán t·∫°i
app.get('/api/passwords', requireAdminAuth, async (req, res) => {
    try {
        const passwords = await getPasswords();
        res.json({ 
            sitePassword: passwords.site_password,
            adminPassword: passwords.admin_password
        });
    } catch (error) {
        console.error("Error fetching passwords:", error);
        res.status(500).json({ error: 'Failed to fetch passwords.' });
    }
});

// POST /api/change-site-password - ƒê·ªïi m·∫≠t kh·∫©u trang ch√≠nh
app.post('/api/change-site-password', requireAdminAuth, async (req, res) => {
    const { newPassword } = req.body;
    if (!newPassword || newPassword.length < 3) {
        return res.status(400).json({ error: 'M·∫≠t kh·∫©u ph·∫£i c√≥ √≠t nh·∫•t 3 k√Ω t·ª±.' });
    }
    
    try {
        await Config.findOneAndUpdate({ key: 'site_password' }, { value: newPassword });
        res.json({ message: 'ƒê√£ ƒë·ªïi m·∫≠t kh·∫©u trang ch√≠nh th√†nh c√¥ng!' });
    } catch (error) {
        console.error("Error changing site password:", error);
        res.status(500).json({ error: 'Failed to change site password.' });
    }
});

// POST /api/change-admin-password - ƒê·ªïi m·∫≠t kh·∫©u admin
app.post('/api/change-admin-password', requireAdminAuth, async (req, res) => {
    const { newPassword } = req.body;
    if (!newPassword || newPassword.length < 3) {
        return res.status(400).json({ error: 'M·∫≠t kh·∫©u ph·∫£i c√≥ √≠t nh·∫•t 3 k√Ω t·ª±.' });
    }
    
    try {
        await Config.findOneAndUpdate({ key: 'admin_password' }, { value: newPassword });
        res.json({ message: 'ƒê√£ ƒë·ªïi m·∫≠t kh·∫©u Admin th√†nh c√¥ng!' });
    } catch (error) {
        console.error("Error changing admin password:", error);
        res.status(500).json({ error: 'Failed to change admin password.' });
    }
});

// GET /api/love-image - L·∫•y URL ·∫£nh t√¨nh y√™u
app.get('/api/love-image', async (req, res) => {
    // API n√†y y√™u c·∫ßu x√°c th·ª±c Site ho·∫∑c Admin
    const authHeader = req.headers['authorization'];
    const passwords = await getPasswords();

    if (authHeader !== passwords.site_password && authHeader !== passwords.admin_password) {
        return res.status(403).json({ error: 'Invalid password.' });
    }
    
    try {
        const result = await Config.findOne({ key: 'love_image' });
        res.json({ image: result ? result.value : null });
    } catch (error) {
        console.error("Error fetching love image:", error);
        res.status(500).json({ error: 'Failed to fetch love image URL.' });
    }
});

// POST /api/upload-url - Upload ·∫£nh t·ª´ URL
app.post('/api/upload-url', requireAdminAuth, async (req, res) => {
    const { imageUrl } = req.body;
    if (!imageUrl) return res.status(400).json({ error: 'URL ·∫£nh l√† b·∫Øt bu·ªôc.' });

    try {
        await Config.findOneAndUpdate({ key: 'love_image' }, { value: imageUrl });
        res.json({ message: 'URL ·∫£nh ƒë√£ ƒë∆∞·ª£c c·∫≠p nh·∫≠t.', image: imageUrl });
    } catch (error) {
        console.error("Error updating image URL:", error);
        res.status(500).json({ error: 'Failed to update image URL.' });
    }
});

// POST /api/upload-file - Upload ·∫£nh t·ª´ file (l∆∞u c·ª•c b·ªô t·∫°m th·ªùi)
app.post('/api/upload-file', requireAdminAuth, upload.single('image'), async (req, res) => {
    if (!req.file) return res.status(400).json({ error: 'File ·∫£nh l√† b·∫Øt bu·ªôc.' });
    
    // L∆∞u file v√†o th∆∞ m·ª•c uploads (C·∫£nh b√°o: T·∫†M TH·ªúI TR√äN RAILWAY/SERVER KH√îNG C√ì PERSISTENT STORAGE)
    const fileExtension = path.extname(req.file.originalname).toLowerCase();
    const fileName = req.file.filename + fileExtension;
    const filePath = path.join(UPLOADS_DIR, fileName);
    
    fs.renameSync(req.file.path, filePath);

    const imageUrl = `/uploads/${fileName}`;

    try {
        await Config.findOneAndUpdate({ key: 'love_image' }, { value: imageUrl });
        res.json({ message: 'File ·∫£nh ƒë√£ ƒë∆∞·ª£c upload th√†nh c√¥ng (t·∫°m th·ªùi).', image: imageUrl });
    } catch (error) {
        console.error("Error uploading file:", error);
        res.status(500).json({ error: 'Failed to process file upload.' });
    }
});

// GET /api/love-messages - L·∫•y danh s√°ch tin nh·∫Øn (cho Admin)
app.get('/api/love-messages', requireAdminAuth, async (req, res) => {
    try {
        const messages = await Message.find().sort({ date: -1 });
        const formattedMessages = messages.map(m => `${m.date.toISOString().split('T')[0]}: ${m.message}`);
        res.json({ messages: formattedMessages });
    } catch (error) {
        console.error("Error fetching love messages (Admin):", error);
        res.status(500).json({ error: 'Failed to fetch messages.' });
    }
});

// POST /api/love-messages - Th√™m tin nh·∫Øn (cho Admin)
app.post('/api/love-messages', requireAdminAuth, async (req, res) => {
    const { message } = req.body;
    if (!message) return res.status(400).json({ error: 'Tin nh·∫Øn l√† b·∫Øt bu·ªôc.' });
    
    try {
        const today = new Date().toISOString().split('T')[0];
        const newMessage = new Message({ date: new Date(today), message });
        await newMessage.save();
        res.json({ message: 'Tin nh·∫Øn ƒë√£ ƒë∆∞·ª£c th√™m th√†nh c√¥ng.' });
    } catch (error) {
        console.error("Error adding love message:", error);
        res.status(500).json({ error: 'Failed to add message.' });
    }
});


// --------------------------------------------------------------------------------
// API CHO TRANG GAME (GAME API)
// --------------------------------------------------------------------------------

// GET /api/game-scores - L·∫•y b·∫£ng x·∫øp h·∫°ng
app.get('/api/game-scores', requireSiteAuth, async (req, res) => {
    try {
        const scores = await GameScore.find().sort({ score: -1 }).limit(10);
        const formattedScores = scores.map(row => ({
            playerName: row.playerName,
            score: row.score,
            level: row.level,
            clicksPerMinute: row.clicksPerMinute,
            date: row.date
        }));
        res.json({ scores: formattedScores });
    } catch (error) {
        console.error("Error fetching game scores:", error);
        res.status(500).json({ error: 'Failed to fetch game scores.' });
    }
});

// POST /api/game-score - L∆∞u ƒëi·ªÉm m·ªõi
app.post('/api/game-score', requireSiteAuth, async (req, res) => {
    const { score, level, clicksPerMinute, playerName } = req.body;
    
    if (typeof score !== 'number' || score < 1) {
        return res.status(400).json({ error: 'ƒêi·ªÉm kh√¥ng h·ª£p l·ªá.' });
    }

    try {
        const newScore = new GameScore({
            playerName: playerName || 'Ng∆∞·ªùi ch∆°i b√≠ m·∫≠t',
            score,
            level: level || 1,
            clicksPerMinute: clicksPerMinute || 0,
        });
        await newScore.save();
        res.json({ message: 'ƒêi·ªÉm ƒë√£ ƒë∆∞·ª£c l∆∞u th√†nh c√¥ng.' });
    } catch (error) {
        console.error("Error saving game score:", error);
        res.status(500).json({ error: 'Failed to save game score.' });
    }
});


// --------------------------------------------------------------------------------
// KH·ªûI ƒê·ªòNG SERVER
// --------------------------------------------------------------------------------

initializeDatabase().then(() => {
    app.listen(PORT, () => {
        console.log(`Server is running at http://localhost:${PORT}`);
    });
});
